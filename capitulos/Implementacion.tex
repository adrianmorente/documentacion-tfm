\chapter{Implementación}

En este capítulo comentaremos a fondo las decisiones tomadas que hemos comentado previamente en base a la especificación, además de describir las implementaciones propuestas con las distintas tecnologías utilizadas. Pondremos el foco no solo en el \textbf{software implícito en el robot} sino también a los componentes desarrollados externos a él, pero que también conforman la arquitectura completa de la plataforma, como lo son el \textbf{sistema operativo}, el \textbf{panel web de administración} y otras herramientas involucradas. Las ideas que por una razón u otra no hayan llegado a implementarse a tiempo, serán definidas en profundidad en apartados posteriores.\\

Para elaborar este capítulo de una forma más legible y entendible, seguiremos una estructura muy similar a la propuesta en el capítulo 3 de \textbf{Especificación de requisitos}.\\


\section{Requisitos generales}


\subsection{Licencias y compartición del software}

En cuanto a licencias y permisos del proyecto, como se anticipó se usarán diversos \textbf{repositorios} en \textit{Github}, que aparecen listados a continuación y descritos en función del contenido (que se elaborará más tarde):

\begin{itemize}
	\item \textbf{\textit{lazarillo-embedded}} \cite{lazarillo-embedded}: se trata del software embebido programado en \textbf{\textit{C++}} que da lógica al robot.
	\item \textbf{\textit{lazarillo-admin-frontend}} \cite{lazarillo-admin-frontend}: es la página web que utilizan los técnicos para supervisar los robots y enviarles determinadas acciones. Se encuentra hecho en \textbf{\textit{React}} y utiliza \textit{WebSockets} para la conexión con el dispositivo.
	\item \textbf{\textit{lazarillo-admin-backend}} \cite{lazarillo-admin-backend}: es un servicio web que actúa como intermediario entre el robot y el servicio de \textbf{\textit{frontend}} para la negociación de la conexión. Está programado en \textbf{\textit{Python}} usando la librería de \textbf{\textit{Flask}} principalmente.
	\item \textbf{\textit{meta-lazarillo}} \cite{meta-lazarillo}: aquí se aloja el \textit{layer} (o ``capa'') personalizada para \textit{The Yocto Project} con la que se especifican las dependencias de \textbf{\textit{Lazarillo}} en la compilación del sistema operativo del robot.
	\item \textbf{\textit{documentacion-tfm}} \cite{documentacion-tfm}: en este repositorio se alojan los fuentes de \textbf{\LaTeX} para generar esta misma documentación que se está leyendo.
\end{itemize}

Todos los repositorios listados se publican bajo la licencia \textbf{\textit{GPL}} en su \textit{versión 3} (cuya última declaración es del 29 de junio de 2007 \cite{gplv3}) y que permite a cualquier interesado utilizar el software e incluso ampliar sus funcionalidades mientras que posteriormente se distribuya con la misma licencia.

Habiendo establecido ésto, entremos en materia y veamos todos los detalles de la implementación.\\


\section{Sistema operativo}

Como comentábamos en el capítulo del \textit{Estado del arte} en el apartado de \textit{Sistema operativo, el cerebro del robot}, existen diversas alternativas para componerlo. Partiendo de la base de que contamos con una \textit{Raspberry} como núcleo del computador, las opciones más sonadas son utilizar \textit{\textbf{Raspbian}} (sistema ya compilado e instalable en la plataforma) o crear nuestra propia distribución utilizando \textbf{el proyecto \textit{Yocto}}.\\

¿Por qué omitimos un sistema operativo que ya existe? Pues bien, la respuesta es fácil. \textit{Raspbian} es un sistema operativo de uso general que permite utilizar la \textit{Raspberry} como cualquier ordenador normal, ya sea para ofimática, desarrollo de software, consumo de recursos multimedia o incluso videojuegos. Esto provoca que el sistema operativo en cuestión venga con demasiado \textit{bloatware} (software innecesario que no se utiliza) preinstalado de base; y llevaría más tiempo modificar la imagen de \textit{Raspbian} para que no contenga todo el software no deseado que confeccionar un sistema operativo a medida. Además, deseamos que el robot solo muestre una aplicación embebida en pantalla en lugar de un entorno de escritorio normal, por lo que podemos prescindir de este entorno completo y configurar nuestro nuevo sistema para que solo muestre una aplicación y ahorre tiempo en el arranque.\\

La ventaja de crear nuestra propia imagen de sistema permitirá que incluyamos solo las librerías y dependencias que realmente necesitemos, obviando aspectos que no nos sea necesario incluir y que tomarían un espacio útil en la máquina. Además, siendo un proyecto de código abierto permitirá que interesados aprovechen el sistema operativo y lo extiendan con las funcionalidades y programas que les apetezca. Pasemos a continuación a comentar la implementación realizada.\\

\textbf{Nota}: este documento no se pretende que sea una guía de cómo utilizar \textit{Yocto} y entender todo su ecosistema, por lo que solo destacaremos las configuraciones personalizadas hechas para darle forma a \textbf{\textit{lazarillo-image}}.\\

Para empezar a trabajar con \textit{Yocto}, lo primero es elegir \textbf{la versión de \textit{Yocto}} a utilizar y seguir su documentación oficial sobre \textit{Quick Build} \cite{yocto-quick-build}, en la que se detalla cómo clonar el proyecto y realizar una primera compilación de prueba. Esta ejecución inicial llevará al menos un par de horas, ya que necesitará descargar todas las librerías necesarias y compilarlas.\\

\begin{figure}[h]
	\centering
	\includegraphics[width=0.85\textwidth]{imagenes/yocto-releases.png}
	\caption{La versión elegida es \textbf{\textit{Dunfell 3.1}} ya que lleva el suficiente tiempo en el mercado como para ser estable, y además es versión \textit{Long Term Support} y asegura soporte oficial hasta abril de 2024. Versiones más novedosas o no \textit{LTS} pueden no asegurar tanta estabilidad. - Fuente: \textit{Yocto Releases} \cite{yocto-releases}}
	\label{yocto-releases}
\end{figure}

Acto seguido, lo que hacemos para continuar con la creación de nuestra propia distribución son varias cosas:

\begin{itemize}
	\item Crear nuestro propio \textit{layer}, llamado \textbf{\textit{meta-lazarillo}} donde estableceremos nuestras directivas.
	\item Crear una \textbf{imagen} de sistema, que se llamará \textbf{\textit{lazarillo-image}} y que incluirá el software programado por nosotros y que se instalará automáticamente en el robot.
	\item Añadir a la imagen creada previamente las dependencias para que sus aplicaciones se ejecuten correctamente.
\end{itemize}

El contenido de este \textit{layer} puede verse en la web \cite{meta-lazarillo} pero igualmente listaremos aquí los archivos más representativos.\\

\subsubsection{conf/layer.conf}

Este primer archivo contiene las variables más genéricas para la configuración inicial del \textit{layer} y suele tener un formato parecido en todos los \textit{metas} que se crean, ya que principalmente fija el nombre característico de la colección además de la rama de \textbf{compatibilidad} (que es \textit{dunfell}) como hemos comentado arriba. 

\begin{lstlisting}
BBPATH .= ":${LAYERDIR}"

BBFILES += "${LAYERDIR}/recipes-*/*/*.bb \
${LAYERDIR}/recipes-*/*/*.bbappend"

BBFILE_COLLECTIONS += "lazarillo"
BBFILE_PATTERN_lazarillo = "^${LAYERDIR}/"
BBFILE_PRIORITY_lazarillo = "1"

LAYERSERIES_COMPAT_lazarillo = "dunfell"
LAYERVERSION_lazarillo = "1"
\end{lstlisting}


\subsubsection{recipes-core/images/lazarillo-image.bb}

A continuación, veamos el archivo que realmente define \textbf{la imagen} del sistema operativo, cuyo nombre utilizaremos cuando queramos compilarlo.

\begin{lstlisting}
inherit core-image lazarillo-class

GLIBC_GENERATE_LOCALES = "es_ES.UTF-8"

###################################################
# Groups of needed packages

CORE_PKGS = " \
	kernel-devicetree \
	kernel-image \
	kernel-modules \
	openssl \
"

MISC_PKGS = " \
	curl \
	nano \
	psplash \
"

QT_PKGS = " \
	qtbase qtbase-plugins qtbase-tools \
	qtdeclarative qtdeclarative-qmlplugins \
	qtgraphicaleffects qtgraphicaleffects-qmlplugins \
	qtmultimedia qtmultimedia qtmultimedia-plugins qtmultimedia-qmlplugins \
	qtquickcontrols qtquickcontrols-qmlplugins \
	qtquickcontrols2 qtquickcontrols2-qmlplugins \
	qtvirtualkeyboard qtvirtualkeyboard-plugins qtvirtualkeyboard-qmlplugins \
"

LAZARILLO_PKGS = " \
	lazarillo-embedded \
"

###################################################
# Installation of grouped packages

IMAGE_FEATURES += " \
	autologin \
"

IMAGE_INSTALL += " \
	${CORE_PKGS} \
	${MISC_PKGS} \
	${QT_PKGS} \
	${LAZARILLO_PKGS} \
"
\end{lstlisting}

Todas las constantes del tipo \emph{X\_PKGS} tan solo son valores auxiliares que se concatenan a \emph{IMAGE\_INSTALL} para que en la compilación se incluyan todas estas dependencias en el sistema de ficheros final.\\

Si nos fijamos en el valor de \emph{LAZARILLO\_PKGS} podemos ver que ahí se lista \textbf{lazarillo-embedded}, que se trata de la aplicación embebida que comentábamos que implementará toda nuestra lógica del robot. Vemos el contenido de su \textbf{receta} (como se llaman en \textit{Yocto} los archivos que definen cómo se debe obtener una pieza de software, compilarla e instalarla en el destino) en el siguiente apartado.\\


\subsubsection{recipes-core/lazarillo-embedded/lazarillo-embedded.bb}

\begin{lstlisting}
# Compiles Qt project with cmake after downloading
inherit cmake_qt5

# AUTOREV references to newest commit
SRCREV = "${AUTOREV}"
LICENSE = "GPLv3"

EXTRA_OECMAKE = "-DCOMPILE_MODE=d"

# Reference to repo where to download the software from
SRC_URI = "git://git@github.com/adrianmorente/lazarillo_hmi.git;protocol=ssh"

DEPENDS += " \
	qtbase \
	qtdeclarative \
	qtgraphicaleffects \
	qtmultimedia \
	qtquickcontrols \
	qtquickcontrols2 \
	qtvirtualkeyboard \
"

do_install() {
	install -d ${D}${bindir}
	install -m 0700 lazarillo-hmi ${D}${bindir}
	install -m 0700 motor-manager ${D}${bindir}
	install -m 0700 web-gateway ${D}${bindir}
}

FILES_${PN} = "${bindir}"
\end{lstlisting}

En el archivo mostrado se configura la \textit{URL} del repositorio del que \textit{Yocto} descargará el proyecto (usando las claves \textit{SSH} configuradas en el dispositivo de compilación).\\

Además, encontramos listadas las dependencias necesarias para la compilación exitosa del proyecto. Como utilizamos el framework \textit{Qt} en su versión \textbf{open source} (disponible en \cite{qt-open-source}) para construir la aplicación embebida, se enumeran las librerías que \textit{Yocto} deberá descargar e instalar también.\\

Para finalizar, con \emph{do\_install} establecemos que se copien al directorio normal de binarios del sistema operativo final (normalmente \emph{/usr/bin}) los tres programas generados por \emph{lazarillo-embedded}, con permisos de escritura, lectura y ejecución solo para el usuario actual. Por ahora nos ceñiremos a lo estrictamente relacionado con \textit{Yocto} y estos servicios los definiremos en detalle más adelante.\\


\subsubsection{Configuración local y compilación}

Una vez que tenemos nuestro \textit{layer} preparado para que \textbf{\textit{bitbake}}, la herramienta en \textit{Python} que gestiona las compilaciones de \textit{Yocto}, pueda encontrar nuestros paquetes y dependencias, pasamos a configurar el archivo \emph{build/conf/local.conf}, que es el realmente imprescindible. En este archivo podríamos haber añadido todo el contenido de configuración necesaria para compilar nuestra imagen, si bien es mucho más limpio utilizar \textit{layers} separados que poder versionar y controlar de forma independiente según la \textit{release} de \textit{Yocto} que queramos usar.\\

El contenido usado para el archivo es el siguiente (se han obviado algunas líneas por defecto de \textit{Yocto} que solo son para desarrollo y que no aportan mucho para el alcance de este documento):

\begin{lstlisting}
MACHINE = "raspberrypi3"

DISTRO = "poky"
DISTRO_FEATURES_append = " alsa alsa-plugins gles2 opengl pulseaudio systemd wifi"
DISTRO_FEATURES_REMOVE_append = " x11 wayland"
PACKAGECONFIG_pulseaudio += " systemd"
VIRTUAL-RUNTIME_init_manager = "systemd"
DISTRO_FEATURES_BACKFILL_CONSIDERED = "sysvinit"

PACKAGE_CLASSES = "package_deb"

BB_NUMBER_THREADS = "4"
PARALLEL_MAKE = "-j 4"

EXTRA_USERS_PARAMS += " usermod -a -G audio root;"
EXTRA_USERS_PARAMS += " usermod -P lazarillo123 root;"

EXTRA_IMAGE_FEATURES ?= "debug-tweaks"
\end{lstlisting}


En primer lugar, fijamos la \emph{MACHINE} de destino para la que queremos compilar, en este caso la \textit{Raspberry Pi 3} como hemos comentado anteriormente. Además, decimos a \textit{Yocto} que genere nuestra imagen de sistema operativo utilizando \emph{poky} como distribución base (que es la \textit{de facto} en la herramienta), además de añadir paquetes como \textit{Alsa}, \textit{Pulseaudio}, \textit{OpenGL} y \textit{Systemd}.\\

\begin{itemize}
	\item \textit{Alsa} y \textit{Pulseaudio} son dependencias para los sistemas de sonido, que aunque no se utilizan actualmente, se incluyen en el sistema para cuando se quieran emitir alertas sonoras a través del servicio \textbf{lazarillo-hmi} y así proporcionar una interfaz más cercana y accesible para los usuarios del robot.
	\item \textit{OpenGL} (y su complemento \textit{GLES2}) se incluyen ya que son requisitos indispensables para que el framework de \textit{Qt} con aplicaciones de interfaz gráfica funcione como esperamos en dispositivos embebidos. Gracias a esto, utilizamos el lenguaje \textit{QML} del framework (basado en \textit{Javascript}) para diseñar dicha aplicación con interfaz táctil.
	\item \textit{Systemd} se establece en el sistema como gestor de servicios y \textbf{demonios} (o \textit{daemons}, pequeños servicios que se ejecutan en segundo plano en el sistema). Este es el gestor de arranque de servicios por defecto en la mayoría de distribuciones modernas que utilizamos hoy en día para escritorio.
\end{itemize}

Para terminar, fijamos a \textit{Bitbake} que utilice 4 hilos en la compilación. Cuantos más se utilicen, más tareas de descarga/compilación/instalación podrán ejecutarse en paralelo. Obviamente dependerá de la máquina utilizada.\\

Para terminar, añadimos una contraseña al usuario \textit{root} por defecto para que no se pueda manipular libremente el robot por consola si se accede por \textit{ssh}.\\

Una vez tenemos listo nuestro \textit{layer} y el archivo \textit{local.conf}, podemos lanzar la orden \textbf{\textit{bitbake lazarillo-image}} en el directorio de desarrollo de \textit{Yocto} y ver cómo comienza a descargar dependencias y compilarlas en la arquitectura de la \textit{RPi}:

\begin{figure}[h]
	\centering
	\includegraphics[width=0.95\textwidth]{imagenes/lazarillo-image-compilation.png}
	\caption{Captura de pantalla de \textit{Ubuntu 22.04} sobre el Subsistema Linux de Windows, usado para la compilación del nuevo sistema operativo.}
	\label{lazarillo-image-compilation}
\end{figure}

Llegados aquí, solo quedará esperar unas horas a que termine todo el proceso. Una vez finalizado, grabaremos el archivo \textbf{\textit{lazarillo-image-raspberrypi3.sdimg}} generado bajo el directorio \emph{build/tmp/deploy/} en la tarjeta de memoria que queramos usar en el robot, la insertamos en la \textit{Raspberry} correspondiente y probamos nuestro nuevo y flamante sistema operativo personalizado.\\


\subsubsection{Personalización del sistema operativo}

Para cerrar con el sistema operativo, comentemos el caso de \textbf{\textit{psplash}} \cite{psplash}, un programa que se instala en \textbf{lazarillo-image.bb} dentro del grupo \emph{MISC\_PKGS} como dependencia externa y que permite mostrar una imagen estática durante el arranque del dispositivo final.\\

Detalles como éste hacen que el dispositivo tenga un aspecto más profesional, dado que en lugar de mostrarse una imagen genérica de \textit{GNU/Linux} o, peor si cabe, una terminal de arranque; el robot mostraría en su pantalla una imagen customizada (que podría ser un logo personalizado del proyecto, si lo hubiera).\\

Basta con integrar esta sencilla aplicación dentro del sistema operativo, cambiar la imagen que se desea mostrar y (re)compilar el sistema operativo. Sin embargo, por falta de tiempo, no he podido generar un logo personalizado para el proyecto que mostrar, por lo que el logo por defecto de \textit{OpenEmbedded} es el mostrado al iniciar.\\

\begin{figure}[h]
	\centering
	\includegraphics[width=0.3\textwidth]{imagenes/openembedded.jpg}
	\caption{Imagen mostrada por \textit{psplash} al arranque de la máquina: logo de \textit{OpenEmbedded}, organización contribuidora activamente en el Proyecto \textit{Yocto} - Fuente: \textit{OpenEmbedded.org} \cite{openembedded}}
	\label{openembedded}
\end{figure}


\section{Arquitectura de Lazarillo}

Una vez que hemos visto la integración completa del sistema operativo, en esta sección enumeraremos los distintos servicios y módulos específicos creados para \textit{Lazarillo} y describiremos el propósito para el que han sido programados. Como venimos comentando, habrá ciertas partes que serán enteramente embebidas en el robot, y por otro lado también existirán otros componentes software que estarán situados ``fuera''. Para hacernos una idea general de todos los entes involucrados en el software, prestemos atención al diagrama de la figura \ref{lazarillo-architecture}.\\

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{imagenes/lazarillo-architecture.png}
	\caption{Diagrama mostrando la arquitectura del proyecto, incluyendo conexiones entre servicios y relaciones internas.}
	\label{lazarillo-architecture}
\end{figure}

A la izquierda del todo, junto al agente denominado \textit{Admin} se ubican los dos servicios web involucrados que ya hemos mencionado (\textbf{lazarillo-admin}, arriba \textbf{frontend} y \textbf{backend} abajo). A su derecha encontramos un rectángulo grande que engloba todo el software enclaustrado (\textbf{lazarillo-embedded}) y para finalizar, la interfaz de usuario (gráfica táctil y sonora) con la que interactuarán los que necesiten de la atención de \textit{Lazarillo}.\\

Para explicar la implementación, separaremos todo el software en tres módulos: uno para el software embebido y otro por cada servicio web (que son dos). Aunque ya venimos anunciando cosas, entraremos a continuación en detalles más profundos de lenguajes de programación y librerías utilizadas.\\


\subsection{lazarillo-embedded}

Si volvemos a mirar el diagrama \ref{lazarillo-architecture}, distinguimos el cuadrado blanco que incluye los módulos presentes en \textit{lazarillo-embedded}. Por un lado tenemos los comprendidos en el rectángulo blanco que se tratan de \textbf{librerías}, las cuales se enlazan al compilar a los \textbf{servicios}, representados por rectángulos grises (y comunicados sobre el búfer de comunicación en azul). En esta sección describiremos la razón de existencia de cada uno y el propósito que persiguen, empezando por las librerías y acabando por los programas que se ejecutan en el robot.\\

Hagamos un pequeño inciso aquí para comentar que la compilación está gestionada con la herramienta \textit{CMake} \cite{cmake}, una opción escalable y muy útil para proyectos grandes. Permite establecer funciones y macros comunes para todos los componentes involucrados dentro de un proyecto, utilizando variables para customizar la compilación. Además, con el uso de \emph{cpack} también permite generar archivos \emph{.deb} entendibles por el sistema operativo para su posterior instalación.\\

Antes de nada, veamos la estructura del proyecto hasta el primer nivel de directorios, sin entrar en cada uno, definiendo cada uno de ellos así como los ficheros presentes y la utilidad de cada uno, aunque algunos con más enjundia se desarrollarán más tarde:\\

\textbf{NOTA:} los directorios se muestran en negrita cursiva y los archivos solo en cursiva.

\begin{itemize}
	\item \textit{\textbf{cmake/}ProjectSetup.cmake}: contiene el código común de \textit{CMake} para la correcta compilación del proyecto. Define las banderas de compilación, rutas donde localizar las librerías necesarias e implementa funciones y macros que utilizarán los servicios para enlazarse con las librerías de las que dependen (\textit{Qt}, \textit{Json}, \textit{Redis} y \textit{Systemd}).
	\item \textit{\textbf{lazarillo-hmi/}}: subproyecto que implementa la aplicación gráfica mostrada en la pantalla táctil del robot.
	\item \textit{\textbf{lazarillo-utils/}}: librería que añade objetos estáticos accesibles para todos los subproyectos. En esta fase solo contiene métodos estáticos para obtener la fecha y hora del sistema y así proveerla de forma estándar a los servicios.
	\item \textit{\textbf{messages-definition/}}: este módulo no es en sí un servicio que se ejecute directamente en el sistema operativo sino una \textbf{librería} de la que se nutren los demás donde se definen los mensajes que utilizan internamente para comunicarse. Ésta a su vez se enlaza con el servicio que describiremos más tarde y cuyo fin es \textbf{serializar} los mensajes.
	\item \textit{\textbf{messaging-broker/}}: esta librería es la que establece toda la comunicación con el servidor de \textit{Redis} para el manejo de \textbf{mensajería sobre \textit{PubSub}}. Contiene clases para gestionar la conexión y utiliza el patrón de diseño \textit{Factory} para la creación de los objetos que publican mensajes y se suscriben a tópicos. Al gestionar la conexión en solo este módulo, si se decidiera cambiar \textit{Redis} por otra alternativa, al ser un comportamiento heredado para los servicios, el cambio debería ser solo un trámite.
	\item \textit{\textbf{motor-manager/}}: idealmente, este directorio contiene un nuevo servicio llamado \textit{motor-manager} cuya idea es la de \textbf{controlar los distintos motores y elementos electrónicos que permiten que el robot se mueva}. Contendría clases distintas por cada elemento conectado e intercambiaría mensajes con todos ellos. Desafortunadamente, \textbf{no ha llegado a implementarse} ninguna funcionalidad en esta fase del proyecto.
	\item \textit{\textbf{serialization/}}: esta librería contiene los tipos de datos para \textbf{serialización} (y deserialización) utilizando el formato \textit{Json}. Realmente se podría prescindir de este módulo y almacenar todos los mensajes como texto plano sobre \textit{Redis} y enviarlos así a los servicios. Lo que permite la serialización es transformar los datos para almacenarlos en un búfer (o cualquier recipiente) y que luego puedan ser reconstruidos en el mismo o en otro dispositivo. Se sigue esta aproximación (\textit{por si acaso}) simplemente por dotar de algo más de escalabilidad al proyecto por si sigue creciendo y se quieren hacer más cosas con los mensajes.
	\item \textit{\textbf{service-base/}}: aunque el nombre pueda inducir a pensar que se trate de un \textit{servicio}, realmente es una librería que incluye interfaces y clases que reutilizarán todos los servicios que quieran crearse posteriormente. Realiza acciones generales interesantes como \textbf{instanciar el bróker de mensajería} (mencionado arriba) y proveer de métodos que se ejecutarán tanto al inicio como al final del resto de programas directamente.
	\item \textit{\textbf{test\_env/}}: si bien esta parte no ha llegado a probarse profusamente, el objetivo que persigue es el de crear un entorno de pruebas para el desarrollo en forma de contenedores de \textit{Docker}. Con un archivo \emph{docker-compose.yml} se levantan dos instancias de éstos, uno que simula los servicios instalados en el robot y otro que mantiene el servidor de \textit{Redis} donde se realiza la comunicación. Usando esto, es posible \textbf{probar el código del robot en nuestra máquina local}, ahorrando tiempo.
	\item \textit{\textbf{web-gateway/}}: esta sencilla aplicación hace de \textit{gateway} entre el robot y el panel externo de administración. Mantiene un servidor \textit{WebSocket} que recibe los comandos de la web, los procesa y traduce a mensajes (de \textit{messages-definition}) que luego publica en \textit{Redis} para que las aplicaciones interesadas y suscritas los reciban. De esta forma, un administrador que usa el panel web puede enviar distintas órdenes.
	\item \textit{.clang-format}: ésto no es más que una recomendación a desarrolladores. Si bien este archivo no aporta funcionalidad como tal al proyecto, sí que lo hace al desarrollo. \textit{ClangFormat} \cite{clang-format} se trata de una herramienta que permite dar formato automático al código conforme se escribe. Si se configura este archivo con el editor de texto y las variables siguiendo las \textbf{guías de estilo} que se acuerden con el equipo de desarrollo, todos los programadores involucrados podrán trabajar sobre un estilo común. Ésto evitará conflictos con el control de versiones cuando alguien inserta espacios sin percatarse o más saltos de línea de la cuenta.
	\item \textit{build.sh}: este archivo es un \textbf{\textit{script}} realmente útil para el desarrollo. Internamente ejecuta los comandos de \textit{CMake} con sus parámetros necesarios, permitiendo customizar el proceso con argumentos simples como \emph{-j8} para utilizar 8 hilos en la compilación, \emph{-c d} para compilar en modo de depuración o \emph{--cpack} para generar los binarios de instalación si la compilación es exitosa. Véase la imagen \ref{lazarillo-build-sh}.
	\item \textit{CMakeLists.txt}: finalmente, este es el archivo central del proyecto. Simplemente utiliza el código de la carpeta \textbf{\textit{cmake/}} para incluir el comportamiento general allí descrito y añade a la compilación cada uno de los módulos (exactamente las librerías y los servicios que ya hemos listado).
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.6\textwidth]{imagenes/lazarillo-build-sh.png}
	\caption{Captura de pantalla del uso del script \emph{build.sh} para compilación de \textit{lazarillo-embedded}.}
	\label{lazarillo-build-sh}
\end{figure}

\subsubsection{messages-definition}

En el punto de implementación alcanzado a la hora de la entrega del proyecto no existen muchos mensajes, pero la librería se ha pensado de forma que sea sencillo añadir mensajes nuevos para los nuevos desarrolladores que quieran participar en ello y utilizar \textit{Lazarillo}.\\

Para ilustrar este comportamiento, veremos dos clases: una \textbf{interfaz genérica} para todos los mensajes y una \textbf{clase objeto} de ejemplo que la implementa. Empecemos por la interfaz (por temas de espacio, se obvian del código las guardas y los comentarios. Si se quiere ver el archivo completo, véase el enlace adjunto en el título de cada fragmento):\\

\textbf{\textit{i\_base\_message.h} \cite{i-base-message}}
\begin{lstlisting}
class IBaseMessage : public serialization::Serializable
{
public:
	~IBaseMessage() {}

	virtual std::string name() const = 0;

	void setHeader(MessageHeader const &p_header)
	{
		m_header = std::make_shared<MessageHeader>(p_header);
	}

	MessageHeader getHeader() const
	{
		return (m_header) ? *m_header : getDefaultHeader();
	}

	MessageHeader getDefaultHeader() const;
	{
		MessageHeader header;
		header.name = name();
		return header;
	}

	virtual serialization::Serializer & serializePayload(serialization::Serializer &p_serializer) const = 0;

	serialization::Serializer & serialize(serialization::Serializer &p_serializer) const override
	{
		return serializePayload(p_serializer);
	}
	
private:
	std::shared_ptr<MessageHeader> m_header;
};
\end{lstlisting}

Vemos que esta clase abstracta hereda de \emph{serialization::Serializable}, presente en el módulo de \textbf{serialization} y que provee los métodos que han de sobreescribirse para añadir los campos al objeto serializado que se guardará en memoria.\\

El mensaje abstracto utiliza una \textit{MessageHeader} que compone la \textbf{cabecera} que heredarán todos los mensajes. Tiene tres campos:

\begin{itemize}
	\item \textbf{name}: nombre del mensaje en cuestión, a cumplimentar por cada clase que herede de \textit{IBaseMessage}.
	\item \textbf{source}: nombre del servicio que lo envía.
	\item \textbf{timestamp}: fecha y hora en la que se compone el mensaje para su envío.
\end{itemize}

Además de proveer métodos de acceso para la cabecera, declara los métodos de serialización y deserialización que implementarán cada una de las clases hijas. Un detalle a considerar en éstos es que reciben y devuelven referencias al objeto de serialización; esto se hace para poder concatenar los campos en una sola línea. Ejemplo:

\begin{lstlisting}
# Sin usar referencias como argumento y retorno:	
p_serializer.add("campo1");	
p_serializer.add("campo2");	
p_serializer.add("campo3");
return p_serializer;

# Usando referencias:
return p_serializer.add("campo1").add("campo2").add("campo3");
\end{lstlisting}

Veamos ahora un ejemplo de mensaje que implemente dicha interfaz. Usaremos la clase \textit{EventConnectionStatus}, que representa el mensaje que se envía del servicio \textbf{web-gateway} al resto de servicios cuando cambia la conexión por \textit{WebSocket} con el portal de administración:\\

\textbf{\textit{event\_connection\_status.h}} \cite{event-connection-status}
\begin{lstlisting}
class EventConnectionStatus : public IBaseMessage
{
public:
	static constexpr char const *NAME{"EVENT_CONNECTION_STATUS"};
	
	explicit EventConnectionStatus(models::ConnectionStatus p_status)
	: m_status{p_status} {}
	
	explicit EventConnectionStatus(serialization::Deserializer &p_deserializer)
	{
		p_deserializer.extract("Status", m_status);
	}
	
	serialization::Serializer & serializePayload(serialization::Serializer &p_serializer) const final
	{
		IBaseMessage::serializePayload(p_serializer);
		return p_serializer.add("Status", m_status);
	}
	
	std::string name() const final { return NAME; }
	
private:
	models::ConnectionStatus m_status{models::ConnectionStatus::UNKNOWN};
};
\end{lstlisting}

Podemos ver que utilizando esta aproximación, el código necesario para crear un nuevo mensaje es bastante sencillo. Simplemente sobreescribe el nombre con el que se identificará al mensaje y especifica qué campos han de añadirse o leerse. La variable que se utiliza en cuestión (\emph{m\_status}) no es más que un enumerado con los posibles estados de la conexión.


\subsubsection{service-base}

Este módulo define el esqueleto abstracto de cada uno de los servicios del robot. Heredando el comportamiento de esta librería, cada uno de los nuevos servicios se ahorran procedimientos rutinarios como instanciar la conexión con la base de datos y el bróker de mensajería.

\subsubsection{lazarillo-hmi}

La tecnología usada por esta aplicación, se ha decidido que sea el framework de \textbf{\textit{Qt}}, que pese a tener modalidades de licencias de pago, permite un uso \textit{open source}. Además, se trata de una tecnología con una amplia comunidad, una documentación muy rica y un gran soporte para dispositivos embebidos. Por otro lado, dispongo de amplia experiencia con dicha herramienta, lo que agiliza enormemente el tiempo de desarrollo.

Se trata de la aplicación que muestra la interfaz táctil al usuario.

\subsubsection{web-gateway}

Este servicio es el \textit{puerto de entrada} a Lazarillo. Realiza la comunicación mediante \textit{Websockets} con \textbf{\textit{lazarillo-admin}}, el portal web a través del cual un técnico puede administrar los distintos robots. \textit{\textbf{Web-gateway}} actúa como intérprete de los mensajes provenientes del \textit{socket} y los publica en la mensajería interna del robot (basada en \textit{Redis}) para informar al resto de servicios de cualquier acción emitida por el servidor.



\subsection{lazarillo-admin-frontend}
\subsection{lazarillo-admin-backend}

Como venimos comentando, además del software embebido en el robot, disponemos de otros módulos externos a él que completan la plataforma.

Este es el título asignado al servicio web que tanto venimos comentando a lo largo de este documento, a través del cual podemos visualizar y gestionar los distintos robots conectados al servidor.\\

Está programado con \textit{NodeJS} (TODO: ref a node) y utiliza librerías para hacer las veces de servidor con \textit{HTTPS} (para la web) y con \textit{Websockets} (para la comunicación con el robot).\\
